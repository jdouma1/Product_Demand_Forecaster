# -*- coding: utf-8 -*-
"""Product_Demand_Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11uThHIjBbnN0ub_MS1k7qK8CaW-eXdpA
"""

# Install pip packages in the current Jupyter kernel
import sys
!{sys.executable} -m pip install numpy
!{sys.executable} -m pip install pandas
!{sys.executable} -m pip install matplotlib
!{sys.executable} -m pip install seaborn
!{sys.executable} -m pip install scikit-learn
!{sys.executable} -m pip install ipywidgets

# Import libraries for data cleaning, preprocessing, and manipulation
from datetime import datetime
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import seaborn as sns
import sklearn as sk
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

# Read dataset into program
url = "https://raw.githubusercontent.com/jdouma1/Product_Demand_Forecaster/refs/heads/main/retail_store_inventory.csv"
dataFrame = pd.read_csv(url)

# Generate info on the dataframe columns, null values, and data types
dataFrame.info()

# Check columns for any incomplete or missing (N/A or 1) values
dataFrame.isna().sum()

# Begin analyzing columns important to linear regression to keep or drop

# In this prpoject, we are creating demand forecast, so precalculated [Demand Forecast] is unnecessary
dataFrame = dataFrame.drop("Demand Forecast", axis=1, inplace=False)

# Describe key statistical values (DESCRIPTIVE METHOD) of the dataframe for analysis prior to building model
dataFrame.describe()

# Extract numerical values necessary for analysis, training, and evaluating model
dataFrame = dataFrame.drop(["Category", "Region", "Weather Condition", "Seasonality"], axis=1, inplace=False)

# IDs cause overfitting and also not useful when applying model, so drop values
# Date does not make sense for our end user application, so discard
dataFrame = dataFrame.drop(["Store ID", "Product ID"], axis=1, inplace=False)
dataFrame = dataFrame.drop("Date", axis=1, inplace=False)

# Create a histogram visualization for unit sales data
plt.hist(dataFrame["Units Sold"], bins=30)
plt.xlabel("Units Sold")
plt.ylabel("Frequency")
plt.title("Histogram")
plt.show()

# Create a scatterplot visualization for unit sales data (seed 42 for reproducability)
# There is no clear connection between the price variable and its impact on sales thusfar
x = dataFrame["Price"].sample(n=1000, random_state=42)
y = dataFrame["Units Sold"].sample(n=1000, random_state=42)

plt.scatter(x, y)

# Add labels and title
plt.xlabel("Price")
plt.ylabel("Units Sold")
plt.title('Scatter Plot')

# Display the plot
plt.show()

# Create the heatmap visualization for unit sales data (seed 42 for reproducability)
sample = dataFrame.sample(n=100, random_state=42)

# Increase figure size to ensure heatmap values are legible
plt.figure(figsize=(11, 5))
sns.heatmap(sample.corr(), annot=True, cmap="YlGnBu")

# [x] represents the independent variables (features) of the dataset
# [y] represents the dependent variable (target) to be predicted from [x]
x = dataFrame.drop("Units Sold", axis=1, inplace=False)
y = dataFrame["Units Sold"]

# Split the data into training and testing sets with 80% (first 54,480 rows) training 20% (last 14,620 rows) testing
# [random_state] is a seed to ensure reproducible results
xTrain, xTest, yTrain, yTest = train_test_split(x, y, test_size=0.2, random_state=42)

# Define the random forest regression model (NON-DESCRIPTIVE METHOD)
# This model chosen because dataset has large standard deviation and complex relationships between columns
# More resource intensive but higher accuracy
rf_model = RandomForestClassifier(n_estimators=10, random_state=42)

# Build the model using the training data split in module above
rf_model.fit(xTrain, yTrain)

# Apply the trained model to create demand forecast (on the test set)
yPred = rf_model.predict(xTest)

# Merge test dataframe with demand forecast and units sold from original dataframe
df_forecast = xTest.copy()
df_forecast.insert(2, "Units Sold", dataFrame["Units Sold"])
df_forecast["Demand Forecast"] = yPred
df_forecast

# Evaluate the model accuracy/performance
accuracy = accuracy_score(yTest, yPred)
print(f'Accuracy: {accuracy}')

# Accuracy score reads incredibly low
# Given the standard deviation and weird data relationships, the dataset is likely skewed and causing this laughably low accuracy

# Create a histogram visualization for demand forecast
plt.hist(df_forecast["Demand Forecast"], bins=50)
plt.xlabel("Demand Forecast (Units)")
plt.ylabel("Frequency")
plt.title("Histogram")
plt.show()

# Create a scatterplot visualization for analyzing forecasted demand to units sold (seed 42 for reproducability)
x = dataFrame["Price"].sample(n=200, random_state=42)
y = dataFrame["Units Sold"].sample(n=200, random_state=42)

plt.scatter(x, y)

x = xTest["Price"].sample(n=200, random_state=42)
y = np.random.choice(yPred, size=200)
plt.scatter(x, y)

# Add labels and title
plt.xlabel("Price")
plt.ylabel("Units Sold")
plt.title('Scatter Plot')
plt.figtext(0.5, 0, "Orange dots are predicted demand", ha="center", fontsize=9)

# Display the plot
plt.show()

# Create the heatmap visualization for analyzing test forecast (seed 42 for reproducability)
sample = df_forecast.sample(n=100, random_state=42)

# Increase figure size to ensure heatmap values are legible
plt.figure(figsize=(11, 5))
sns.heatmap(sample.corr(), annot=True, cmap="YlGnBu")

import ipywidgets as widgets
from ipywidgets import Output, Layout, Box
from IPython.display import display, HTML

# The style convention for the text box description sizes
style = {"description_width": "180px"}

# The text boxes where the user can input values to create demand forecast
inventoryLevel_widget = widgets.FloatText(description="Inventory Level (Integer)", style=style, value="42")
unitsOrdered_widget = widgets.FloatText(description="Units Ordered (Integer)", style=style, value="24")
price_widget = widgets.FloatText(description="Price (Float)", style=style, value="19.99")
discount_widget = widgets.FloatText(description="Discount (Integer Percentage)", style=style, value="0")
holidayPromotion_widget = widgets.FloatText(description="Holiday/Promotion (0 or 1)", style=style, value="0")
compPricing_widget = widgets.FloatText(description="Competitor Pricing (Float)", style=style, value="20.99")

# A button for the user to get predictions using input valus and a widget to handle output
forecast_button = widgets.Button(description="Forecast", layout=Layout(justify_content="center"))
output = widgets.Output()

# Labels for header and footer instructions
header_label = widgets.Label("Enter inventory details to create a forecast")
footer_label = widgets.Label(value='Enter values and press the \"Forecast\" button.')

# Bold the header and footer using CSS styling
header_label.add_class("bold-label")
footer_label.add_class("bold-label")
display(HTML("<style>.bold-label { font-weight: bold; }</style>"))

# Create list of vBox contens to enhance readability
vb_contents_list = [header_label,
                    inventoryLevel_widget,
                    unitsOrdered_widget,
                    price_widget,
                    discount_widget,
                    holidayPromotion_widget,
                    compPricing_widget,
                    footer_label]

# Displays the text boxes and buttons inside a VBox with these features
box_layout = Layout(display="flex",
                    flex_flow="column",
                    align_items="center",
                    width="50%")

# Display widgets for instructions, form fill out, and output
vb=widgets.VBox(vb_contents_list, layout=box_layout)
display(vb)

output_vb=widgets.VBox([forecast_button, output], layout=box_layout)
display(output_vb)

# Defines what happens when you click the [Forecast] button
# Displays demand forecast plus 3 visualizations
out = "hi"
@output.capture()
def on_click_forecast(b):
    # Apply the model to create demand forecast
    data = {"Inventory Level": [int(inventoryLevel_widget.value)],
            "Units Ordered": [int(unitsOrdered_widget.value)],
            "Price": [float(price_widget.value)],
            "Discount": [int(discount_widget.value)],
            "Holiday/Promotion": [int(holidayPromotion_widget.value)],
            "Competitor Pricing": [float(compPricing_widget.value)]}
    # Create DataFrame from dictionary of data
    df = pd.DataFrame(data)
    forecast = rf_model.predict(df)
    with output:
        output.clear_output()
        print("Forecast = "+ str(int(forecast[0])) + " Units Sold")

forecast_button.on_click(on_click_forecast)

